/**
 *  MIMOlite device type for garage door button, including power failure indicator.  Be sure mimolite has jumper removed before
 *  including the device to your hub, and tap Config to ensure power alarm is subscribed.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  Updates:
 *  -------
 *  02-18-2016 : Initial commit
 *  03-05-2016 : Changed date format to MM-dd-yyyy h:mm a
 *  03-11-2016 : Due to ST's v2.1.0 app totally hosing up SECONDARY_CONTROL, implemented a workaround to display that info in a separate tile.
 *  08-27-2016 : Modified the device handler for my liking, primarly for looks and feel.
 *  01-08/2017 : Added code for Health Check capabilities/functions.
 *  02-11-2017 : Cleaned up code, and used secondary_control again for messages.
 *  03-11-2017 : Cleaned up code.
 *  03-24-2017 : Changed color schema to match ST's new format.
 *  04-08-2017 : Updated the updated() section to call configuration().
 *  05-19-2017 : Added additional attributeStates to match ST's DTH which should make this work with ActionTiles, and to use contact as the main tile instead of switch due to personal preference.
 *  05-20-2017 : Redefined tiles/names to be similar to the Linear-type opener DTH's, which should make this work with ActionTiles.
 *  05-23-2017 : Made the delay longer for retreiving device info (gets) after the main tile or the refresh tile is tapped.
 *  09-22-2019 : converted DH to Hubitat and added refresh before each action
 *  10-07-2019 : removed extra refresh from open/close it caused to much delay
 *  01-01-2020 : made backwards compatible with stock Hubitat DH
 *  02-26-2020 : added door open/close timing and software lock for extra security to disable door opening set the momentary switch delay setting as default 30 (3 sec) if you want to disable and manually control the on/off function select 0 (disabled) in device settings
 *  03-01-2020 : added logic so the DH should not get out of sequence with the garage door and the garage door can not be activated unless fully open or closed and removed "doorstate" as it was redundant 
 *  04-15-2020 : fixed an error in refresh, added auto refresh, and auto close
 */
metadata {
    definition (name: "MIMOlite Garage Door Controller 04/15/2020", namespace: "Hubitat", author: "scgs350", modified: "NoWon", importUrl: "https://raw.githubusercontent.com/NoWon69/mimolite/master/mimolite%20garage%20door%20DH") 
    {
        
        capability "Momentary"
        capability "Relay Switch"
        capability "Polling"
        capability "Refresh"
        capability "Switch"
        capability "Sensor"
        capability "Contact Sensor"
        capability "Configuration"
        capability "Actuator"
        capability "Door Control"
        capability "Garage Door Control"
        capability "Health Check"
        capability "Lock"    
        
        attribute "powered", "string"
        attribute "switch", "string"
        attribute "setSwitchDelay", "number"     
        
        command "open"
        command "close"
        command "lock"
        command "unlock"
        command "on"
        command "off"        
        command "setSwitchDelay",[[title:"momentary switch delay", name:"select momentary switch delay 0(disabled),1,2,3 default 3(3 sec)", type:"NUMBER", description:"momentary switch delay", constraints:["NUMBER"]]]               
        
fingerprint mfr: "132", deviceId: "0x1000", prod:"1107", inClusters: "0x72,0x86,0x71,0x30,0x31,0x35,0x70,0x85,0x25,0x03", deviceJoinName: "mimolite garage door"
    }

preferences {
    input "doortimer", "enum", title:"door full open or close Time", required:false, defaultValue:20, options:[0:"disabled", 10:"10 sec", 20:"20 sec (default)", 30:"30 sec", 45:"45 sec", 60:"1 Minutes", 300:"5 Minutes", 600:"10 Minutes"]
//    input "SwitchDelay", "enum", title:"momentary switch delay", required:false, defaultValue:0, options:[0:"0 sec (disabled)", 10:"1 sec", 20:"2 sec", 30:"3 sec"] 
    input name: "logenable", type: "bool", title: "Enable debug logging", defaultValue: false
    input "autorefresh", "enum", title:"auto Refresh", required:false, defaultValue:0, options:[0:"disabled (default)", 1:"15 minutes", 2:"30 minutes", 3:"1 hour", 4:"3 hours"]    
    input "autoclose", "enum", title:"auto close", required:false, defaultValue:0, options:[0:"disabled (default)", 10:"10 minutes", 15:"15 minutes", 30:"30 minutes", 60:"1 hour", 180:"3 hours"]
    }
}

def autoClose() {
    autoclose = Integer.parseInt(autoclose)
    if (autoclose == null) {
        sendEvent(name: "auto_close", value: "disabled")        
        log.info "auto close null disabled"
        unschedule(close) 
    }
    if (autoclose == 0) {
        sendEvent(name: "auto_close", value: "disabled")        
        log.info "auto close disabled"
        unschedule(close) 
    }
    if (autoclose == 10) {
        sendEvent(name: "auto_close", value: "10 minutes")
        log.info "auto close 10 minutes"
        runIn(60*autoclose, close) 
    }
    if (autoclose == 15) {
        sendEvent(name: "auto_close", value: "15 minutes")
        log.info "auto close 15 minutes"
        runIn(60*autoclose, close) 
    }  
    if (autoclose == 30) {
        sendEvent(name: "auto_close", value: "30 minutes")
        log.info "auto close 15 minutes"
        runIn(60*autoclose, close) 
    }
    if (autoclose == 60) {
        sendEvent(name: "auto_close", value: "1 hour")
        log.info "auto close 1 hour"
        runIn(60*autoclose, close) 
    }
    if (autoclose == 180) {
        sendEvent(name: "auto_close", value: "3 hours")
        log.info "auto close 3 hours"
        runIn(60*autoclose, close) 
    }      
}

def autoRefresh() {
    autorefresh = Integer.parseInt(autorefresh)
    if (autorefresh == null) {
        log.info "auto refresh null disabled"
        sendEvent(name: "auto_refresh", value: "disabled") 
        unschedule(refresh)
    }
    if (autorefresh == 0) {
        log.info "auto refresh disabled"
        sendEvent(name: "auto_refresh", value: "disabled")
        unschedule(refresh) 
    }
    if (autorefresh == 1) {
        log.info "auto refresh every 15 minutes"
        sendEvent(name: "auto_refresh", value: "15 minutes")
        runEvery15Minutes(refresh) 
    }
    if (autorefresh == 2) {
        log.info "auto refresh every 30 minutes" 
        sendEvent(name: "auto_refresh", value: "30 minutes")
        runEvery30Minutes(refresh) 
    }
    if (autorefresh == 3) {
        log.info "auto refresh every 1 hour"
        sendEvent(name: "auto_refresh", value: "1 hour")
        runEvery1Hour(refresh)
    }
    if (autorefresh == 4) {
        log.info "auto refresh every 3 hours" 
        sendEvent(name: "auto_refresh", value: "3 hours")
        runEvery3Hours(refresh) 
    } 
 }   
   
def setSwitchDelay(value) {
    if (value == null) {
        sendEvent(name: "momentary_switch_delay", value: "3 sec", displayed: true)
        log.warn "incomplete parameter list supplied..."
        log.info "momentay switch enabled set to default 30 (3 sec)"        
        return delayBetween([
            secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 30, parameterNumber: 11, size: 1)),
            secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))
        ],500) 
    }
    if (value == 0) {
        sendEvent(name: "momentary_switch_delay", value: "disabled", displayed: true)
        log.info "set default 0 sec switch delay, momentay state disabled"    
        return delayBetween([
            secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 0, parameterNumber: 11, size: 1)),
            secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))
        ],500) 
    }
    if (value == 1) {
        sendEvent(name: "momentary_switch_delay", value: "1 sec", displayed: true)
        log.info "momentay switch state enabled 1 sec"     
        return delayBetween([
            secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 10, parameterNumber: 11, size: 1)),
            secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))   
        ],500) }
    if (value == 2) {
        sendEvent(name: "momentary_switch_delay", value: "2 sec", displayed: true)
        log.info "momentay switch state enabled 2 sec"    
        return delayBetween([
            secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 20, parameterNumber: 11, size: 1)),
            secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))
        ],500) 
    }
    if (value == 3) {
        sendEvent(name: "momentary_switch_delay", value: "3 sec", displayed: true)
        log.info "momentay switch state enabled 3 sec"      
        return delayBetween([
            secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 30, parameterNumber: 11, size: 1)),
            secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))
        ],500) 
    }
}

def timer() {
    if (doortimer == null) {
        timer=20
    } 
    else {
        timer=Integer.parseInt(doortimer)
    }
}

def door_timer() {
    sendEvent(name: "door_timer", value: timer())
}

def parse(String description) {
    if (logenable) log.debug "description is: ${description}"
    def result = null
    def cmd = zwave.parse(description, [0x72: 1, 0x86: 1, 0x71: 1, 0x30: 1, 0x31: 5, 0x35: 1, 0x70: 1, 0x85: 1, 0x25: 1, 0x03: 1, 0x20: 1, 0x84: 1])
    if (logenable) log.debug "command value is: $cmd"			
//Mimo sent a power loss report
    if (cmd.CMD == "7105") {	
        log.debug "command value is: $cmd"
        log.warn "Device lost power"
        sendEvent(name: "powered", value: "powerOff", descriptionText: "$device.displayName lost power")
    } else {
        sendEvent(name: "powered", value: "powerOn", descriptionText: "$device.displayName regained power")
    }
    if (cmd) {
        result = createEvent(zwaveEvent(cmd))
    }
//    if (logenable) log.debug "Parse returned ${result?.descriptionText}"
    def statusTextmsg = ""
    def timeString = new Date().format("MM-dd-yy h:mm a", location.timeZone)
    statusTextmsg = "Last updated: "+timeString
    sendEvent("name":"statusText", "value":statusTextmsg)
    return result
}

def sensorValueEvent(Short value) {
    if (value) {
        sendEvent(name: "contact", value: "open")
        sendEvent(name: "door_timer", value: timer())
        sendEvent(name:"lock", value:"Door is unlocked")
        autoClose()
        runIn(timer(), refresh)
    } 
    else {
        sendEvent(name: "contact", value: "closed")
        sendEvent(name: "door", value: "closed")
        sendEvent(name: "door_timer", value: timer())
        sendEvent(name: "switch", value: "off")
        refresh()        
    }
}

def zwaveEvent(hubitat.zwave.commands.basicv1.BasicReport cmd) {
    [name: "switch", value: cmd.value ? "on" : "off", type: "physical"]
}

def zwaveEvent(hubitat.zwave.commands.basicv1.BasicSet cmd)
{
    sensorValueEvent(cmd.value)
}

def zwaveEvent(hubitat.zwave.commands.sensorbinaryv1.SensorBinaryReport cmd)
{
    sensorValueEvent(cmd.sensorValue)
}

//we caught this up in the parse method. This method not used.
def zwaveEvent(hubitat.zwave.commands.alarmv1.AlarmReport cmd)
{
    log.warn "We lost power"
}

// Handles all Z-Wave commands we aren't interested in
def zwaveEvent(hubitat.zwave.Command cmd) {
    [:]
}
        
def lock() {
    log.info "locked door"
    sendEvent(name:"lock", value:"Door is locked")
}

def unlock() {
    log.info "unlocked door"
    sendEvent(name:"lock", value:"Door is unlocked")
}

def set_doorstate_to_opened() {
    sendEvent(name: "door", value: "open")
    autoClose()
    return delayBetween([   
        secureCmd(zwave.basicV1.basicGet()),
        secureCmd(zwave.sensorBinaryV1.sensorBinaryGet())
    ],1000) 
}

def set_doorstate_to_closed() {
    sendEvent(name: "door", value: "closed")
    sendEvent(name: "switch", value: "off")    
    return delayBetween([
        zwave.basicV1.basicSet(value: 0x00).format(),
        zwave.basicV1.basicGet().format(),
        secureCmd(zwave.basicV1.basicGet()),
        secureCmd(zwave.sensorBinaryV1.sensorBinaryGet())        
    ],1000) 
}

def on() {
    if (device.currentValue("lock") == "Door is unlocked" & (device.currentValue("contact") == "closed" & device.currentValue("switch") == "off")) {        
        log.info "Sending on open cmd to open garage door"
        sendEvent(name: "door", value: "opening")
        sendEvent(name: "switch", value: "on")        
        runIn(timer(), set_doorstate_to_opened)
        return delayBetween([      
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format()                
        ],1000)       
        }
    if (device.currentValue("contact") == "open" & device.currentValue("door") != "opening" & device.currentValue("door") != "closing" & device.currentValue("switch") == "off") {
        log.info "Sending on close cmd to close garage door"
        sendEvent(name: "door", value: "closing")
        sendEvent(name: "switch", value: "on")        
        runIn(timer(), set_doorstate_to_closed)
        return delayBetween([      
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format() 
        ],1000)
    }
    else {   
        log.warn "no on cmd sent, door is locked or moving or switch is already on"
    }
}        
    
def off() {  
    log.info "Sending off cmd to door switch"
    sendEvent(name: "switch", value: "off")
    return delayBetween([
        zwave.basicV1.basicSet(value: 0x00).format(),
        zwave.basicV1.basicGet().format()
    ],1000)       
}

def open() {
    if (device.currentValue("lock") == "Door is unlocked" & device.currentValue("contact") == "closed") {
        log.info "Sending open cmd to open garage door"
        sendEvent(name: "door", value: "opening")
        sendEvent(name: "contact", value: "open")
        runIn(timer(), set_doorstate_to_opened)
        return delayBetween([ 
            zwave.basicV1.basicSet(value: 0x00).format(),        
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format()                
        ],1000)
    }    
    else {
        log.warn "no open cmd sent door is already open or locked"
    }
}

def close() {
    if (device.currentValue("contact") == "open" & device.currentValue("door") != "opening" & device.currentValue("door") != "closing") {
        log.info "Sending close cmd to close garage door"
        sendEvent(name: "door", value: "closing")
        runIn(timer(), set_doorstate_to_closed)       
        return delayBetween([ 
            zwave.basicV1.basicSet(value: 0x00).format(),        
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format()                
        ],1000)
    }
    else {
        log.warn "No close cmd sent door is already closed or in transit"        
    }
}

def push() {  
    if (device.currentValue("lock") == "Door is unlocked" & device.currentValue("contact") == "closed") {
        log.info "Sending push open event to open garage door"
        sendEvent(name: "door", value: "opening")
        runIn(timer(), set_doorstate_to_opened)
        return delayBetween([ 
            zwave.basicV1.basicSet(value: 0x00).format(),        
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format()                
        ],1000)
    }
    if (device.currentValue("contact") == "open" & device.currentValue("door") != "opening" & device.currentValue("door") != "closing") {
        log.info "Sending push close event to close garage door"
        sendEvent(name: "door", value: "closing")
        runIn(timer(), set_doorstate_to_closed)        
        return delayBetween([ 
            zwave.basicV1.basicSet(value: 0x00).format(),        
            zwave.basicV1.basicSet(value: 0xFF).format(),
            zwave.basicV1.basicGet().format()                
        ],1000)
    }      
    else {   
        log.warn "no push cmd sent, door is locked or moving"
    }
}        

def poll() {
    refresh()
}

// PING is used by Device-Watch in attempt to reach the Device
def ping() {
    refresh()
}

def refresh() {
    log.info "Refreshing"
//    unschedule(refresh)
    autoRefresh()
    return delayBetween([
        secureCmd(zwave.switchBinaryV1.switchBinaryGet()),
 // get sig1 input door contact state             
        secureCmd(zwave.sensorBinaryV1.sensorBinaryGet()),       
//
        secureCmd(zwave.basicV1.basicGet()),
// get alert thresholds setting        
        secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 8)),
// get alarms setting        
        secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 9)), 
// get momentary switch setting        
        secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))
    ],1000) 
}

def configure() {
    log.info "Configuring defaults" //setting up to monitor power alarm and actuator duration 
    log.info "momentay switch state enabled 3 sec"  
    sendEvent(name: "door_timer", value: timer())
    sendEvent(name: "momentary_switch_delay", value: "2 sec")
    sendEvent(name: "switch", value: "off")
    sendEvent(name:"lock", value:"Door is unlocked")
    unschedule(close)
    autoclose = 0
    sendEvent(name: "auto_close", value: "disabled") 
    unschedule(refresh)
    autorefresh = 0
    sendEvent(name: "auto_refresh", value: "disabled") 
    return delayBetween([
// enable analog alert thresholds for door contacts 0 disables   
        secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 3, parameterNumber: 8, size: 1)),
// tell device to send multivalue sensor updates every 1 = 10 seconds 
        secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 5, parameterNumber: 9, size: 1)),
// sets momentary switch set 0-30 0 (disabled) 10 = 1 seconds configured default for 20 (2 sec)      
        secureCmd(zwave.configurationV1.configurationSet(scaledConfigurationValue: 20, parameterNumber: 11, size: 1)),
// enable alarms to be sent to hub  
        secureCmd(zwave.associationV1.associationSet(groupingIdentifier:3, nodeId:[zwaveHubNodeId])),
// enable multivalue sensor updates to be sent to hub
        secureCmd(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:[zwaveHubNodeId])),
// sets switch to off
        zwave.basicV1.basicSet(value: 0x00).format(),
        zwave.basicV1.basicGet().format()
    ],1000)
}

def getSwitchDelay() {
    def cmds = []
        cmds = [secureCmd(zwave.configurationV1.configurationGet(parameterNumber: 11))]
}	

def zwaveEvent(hubitat.zwave.commands.configurationv1.ConfigurationReport cmd) {
    log.info "ConfigurationReport- parameterNumber:${cmd.parameterNumber}, size:${cmd.size}, value:${cmd.scaledConfigurationValue}"
}

private secureCmd(cmd) {
    if (getDataValue("zwaveSecurePairingComplete") == "true") {
        return zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
    }
    else {
        return cmd.format()
    }	
}       
